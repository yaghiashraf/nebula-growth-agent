import { Octokit } from '@octokit/rest';
import { createAppAuth } from '@octokit/auth-app';
import { logger, componentLogger } from '../lib/logger';
import { config } from '../lib/config';
import type { GitHubPatch, PatchData } from '../types';

export class GitHubPatcher {
  private octokit: Octokit;
  private appId: string;
  private privateKey: string;

  constructor() {
    this.appId = config.GITHUB_APP_ID;
    this.privateKey = config.GITHUB_PRIVATE_KEY;
    
    this.octokit = new Octokit({
      authStrategy: createAppAuth,
      auth: {
        appId: this.appId,
        privateKey: this.privateKey,
      },
    });
  }

  async createPullRequest(
    patch: GitHubPatch,
    installationId: string
  ): Promise<{ prNumber: number; prUrl: string }> {
    try {
      // Get installation access token
      const { data: installation } = await this.octokit.rest.apps.getInstallation({
        installation_id: parseInt(installationId),
      });

      const authenticatedOctokit = new Octokit({
        auth: `token ${installation.access_tokens_url}`,
      });

      // Create a new branch
      const branchName = `nebula-growth-${Date.now()}`;
      
      // Get the default branch
      const { data: repo } = await authenticatedOctokit.rest.repos.get({
        owner: patch.owner,
        repo: patch.repository,
      });

      const defaultBranch = repo.default_branch;

      // Get the latest commit SHA from the default branch
      const { data: ref } = await authenticatedOctokit.rest.git.getRef({
        owner: patch.owner,
        repo: patch.repository,
        ref: `heads/${defaultBranch}`,
      });

      // Create new branch
      await authenticatedOctokit.rest.git.createRef({
        owner: patch.owner,
        repo: patch.repository,
        ref: `refs/heads/${branchName}`,
        sha: ref.object.sha,
      });

      // Create or update files
      const commitShas: string[] = [];
      
      for (const file of patch.files) {
        try {
          // Check if file exists
          let existingFile;
          try {
            const { data } = await authenticatedOctokit.rest.repos.getContent({
              owner: patch.owner,
              repo: patch.repository,
              path: file.path,
              ref: branchName,
            });
            existingFile = data;
          } catch (error) {
            // File doesn't exist, we'll create it
            existingFile = null;
          }

          // Create or update file
          const { data: commit } = await authenticatedOctokit.rest.repos.createOrUpdateFileContents({
            owner: patch.owner,
            repo: patch.repository,
            path: file.path,
            message: `Update ${file.path}`,
            content: Buffer.from(file.content, file.encoding || 'utf-8').toString('base64'),
            branch: branchName,
            sha: existingFile && 'sha' in existingFile ? existingFile.sha : undefined,
          });

          commitShas.push(commit.commit.sha);
        } catch (error) {
          logger.error('Failed to update file', { error, filePath: file.path });
          throw error;
        }
      }

      // Create pull request
      const { data: pr } = await authenticatedOctokit.rest.pulls.create({
        owner: patch.owner,
        repo: patch.repository,
        title: patch.prTitle,
        head: branchName,
        base: defaultBranch,
        body: this.generatePRDescription(patch),
        draft: !config.AUTO_MERGE,
      });

      componentLogger.github.prCreated(
        `${patch.owner}/${patch.repository}`,
        pr.number,
        pr.html_url
      );

      // Auto-merge if enabled
      if (config.AUTO_MERGE) {
        await this.autoMergePR(authenticatedOctokit, patch.owner, patch.repository, pr.number);
      }

      return {
        prNumber: pr.number,
        prUrl: pr.html_url,
      };
    } catch (error) {
      componentLogger.github.error(`${patch.owner}/${patch.repository}`, error as Error);
      throw error;
    }
  }

  private generatePRDescription(patch: GitHubPatch): string {
    const description = `${patch.prDescription}

## ðŸ¤– Nebula Growth Agent

This PR was automatically generated by Nebula Growth Agent based on performance analysis and competitor intelligence.

### Changes Made:
${patch.files.map(file => `- **${file.path}**: Modified for growth optimization`).join('\n')}

### Expected Impact:
- Improved user engagement
- Better SEO performance
- Enhanced conversion rates

### Testing:
- [ ] Lighthouse performance score maintained or improved
- [ ] No accessibility regressions
- [ ] Visual diff reviewed
- [ ] A/B test ready (if applicable)

---
*Generated by [Nebula Growth Agent](https://nebula-growth-agent.com)*`;

    return description;
  }

  private async autoMergePR(
    octokit: Octokit,
    owner: string,
    repo: string,
    prNumber: number
  ): Promise<void> {
    try {
      // Wait for checks to complete
      await this.waitForChecks(octokit, owner, repo, prNumber);

      // Enable auto-merge
      await octokit.rest.pulls.merge({
        owner,
        repo,
        pull_number: prNumber,
        commit_title: 'Auto-merge: Growth optimization update',
        commit_message: 'Automatically merged after passing all checks',
        merge_method: 'squash',
      });

      componentLogger.github.prMerged(`${owner}/${repo}`, prNumber);
    } catch (error) {
      logger.error('Failed to auto-merge PR', { error, owner, repo, prNumber });
      throw error;
    }
  }

  private async waitForChecks(
    octokit: Octokit,
    owner: string,
    repo: string,
    prNumber: number,
    maxWaitTime = 600000 // 10 minutes
  ): Promise<void> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < maxWaitTime) {
      try {
        const { data: pr } = await octokit.rest.pulls.get({
          owner,
          repo,
          pull_number: prNumber,
        });

        if (pr.mergeable_state === 'clean') {
          return;
        }

        if (pr.mergeable_state === 'blocked') {
          throw new Error('PR is blocked and cannot be merged');
        }

        // Wait 30 seconds before checking again
        await new Promise(resolve => setTimeout(resolve, 30000));
      } catch (error) {
        logger.error('Error waiting for checks', { error, owner, repo, prNumber });
        throw error;
      }
    }

    throw new Error('Timeout waiting for PR checks to complete');
  }

  async createPatch(
    targetUrl: string,
    currentContent: string,
    suggestedContent: string,
    patchType: 'content' | 'html' | 'css' | 'json' | 'image' = 'content'
  ): Promise<PatchData> {
    try {
      // Generate file path based on URL
      const url = new URL(targetUrl);
      const filePath = this.generateFilePath(url.pathname, patchType);

      const patch: PatchData = {
        type: patchType,
        filePath,
        oldContent: currentContent,
        newContent: suggestedContent,
        metadata: {
          targetUrl,
          timestamp: new Date().toISOString(),
          patchType,
        },
      };

      return patch;
    } catch (error) {
      logger.error('Failed to create patch', { error, targetUrl });
      throw error;
    }
  }

  private generateFilePath(urlPath: string, patchType: string): string {
    // Simple file path generation logic
    // In production, this would be more sophisticated
    switch (patchType) {
      case 'html':
        return urlPath === '/' ? 'index.html' : `${urlPath.replace(/^\//, '')}.html`;
      case 'css':
        return 'styles/main.css';
      case 'json':
        return 'data/schema.json';
      case 'image':
        return 'images/optimized.jpg';
      default:
        return urlPath === '/' ? 'index.html' : `${urlPath.replace(/^\//, '')}.html`;
    }
  }

  async generateContentPatch(
    htmlContent: string,
    targetSelector: string,
    newContent: string
  ): Promise<string> {
    try {
      // Simple content replacement
      // In production, use a proper HTML parser
      const selectorRegex = new RegExp(`(<${targetSelector}[^>]*>)(.*?)(</${targetSelector}>)`, 'is');
      const match = htmlContent.match(selectorRegex);

      if (match) {
        return htmlContent.replace(selectorRegex, `$1${newContent}$3`);
      }

      // If selector not found, append to body
      return htmlContent.replace('</body>', `${newContent}\n</body>`);
    } catch (error) {
      logger.error('Failed to generate content patch', { error, targetSelector });
      return htmlContent;
    }
  }

  async generateSEOPatch(
    htmlContent: string,
    improvements: {
      title?: string;
      metaDescription?: string;
      headings?: Array<{ level: number; text: string }>;
      altTexts?: Array<{ selector: string; altText: string }>;
    }
  ): Promise<string> {
    try {
      let patchedContent = htmlContent;

      // Update title
      if (improvements.title) {
        patchedContent = patchedContent.replace(
          /<title>.*?<\/title>/i,
          `<title>${improvements.title}</title>`
        );
      }

      // Update meta description
      if (improvements.metaDescription) {
        const metaRegex = /<meta\s+name=["']description["']\s+content=["'].*?["']\s*\/?>/i;
        const newMeta = `<meta name="description" content="${improvements.metaDescription}">`;
        
        if (metaRegex.test(patchedContent)) {
          patchedContent = patchedContent.replace(metaRegex, newMeta);
        } else {
          patchedContent = patchedContent.replace('</head>', `${newMeta}\n</head>`);
        }
      }

      // Update headings
      if (improvements.headings) {
        improvements.headings.forEach(heading => {
          const headingRegex = new RegExp(`<h${heading.level}[^>]*>.*?</h${heading.level}>`, 'i');
          const newHeading = `<h${heading.level}>${heading.text}</h${heading.level}>`;
          patchedContent = patchedContent.replace(headingRegex, newHeading);
        });
      }

      // Update alt texts
      if (improvements.altTexts) {
        improvements.altTexts.forEach(altText => {
          const imgRegex = new RegExp(`<img([^>]*?)alt=["'][^"']*["']([^>]*?)>`, 'gi');
          patchedContent = patchedContent.replace(imgRegex, `<img$1alt="${altText.altText}"$2>`);
        });
      }

      return patchedContent;
    } catch (error) {
      logger.error('Failed to generate SEO patch', { error });
      return htmlContent;
    }
  }

  async rollbackPR(
    owner: string,
    repo: string,
    prNumber: number,
    installationId: string
  ): Promise<void> {
    try {
      // Get installation access token
      const { data: installation } = await this.octokit.rest.apps.getInstallation({
        installation_id: parseInt(installationId),
      });

      const authenticatedOctokit = new Octokit({
        auth: `token ${installation.access_tokens_url}`,
      });

      // Close the PR
      await authenticatedOctokit.rest.pulls.update({
        owner,
        repo,
        pull_number: prNumber,
        state: 'closed',
      });

      // Delete the branch
      const { data: pr } = await authenticatedOctokit.rest.pulls.get({
        owner,
        repo,
        pull_number: prNumber,
      });

      await authenticatedOctokit.rest.git.deleteRef({
        owner,
        repo,
        ref: `heads/${pr.head.ref}`,
      });

      logger.info('PR rolled back successfully', { owner, repo, prNumber });
    } catch (error) {
      logger.error('Failed to rollback PR', { error, owner, repo, prNumber });
      throw error;
    }
  }
}

export default GitHubPatcher;